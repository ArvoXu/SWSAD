<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M21 17H3V5H21V17M21 3H3C1.9 3 1 3.9 1 5V17C1 18.1 1.9 19 3 19H21C22.1 19 23 18.1 23 17V5C23 3.9 22.1 3 21 3M12 16H14V14H16V12H14V10H12V12H10V14H12V16M7 11.5C7 12.3 6.3 13 5.5 13S4 12.3 4 11.5 4.7 10 5.5 10S7 10.7 7 11.5M19 11.5C19 12.3 18.3 13 17.5 13S16 12.3 16 11.5 16.7 10 17.5 10S19 10.7 19 11.5Z' fill='gray'/%3E%3C/svg%3E">
    <title>智慧倉儲與銷售分析儀表板</title>
    <!-- 添加Chart.js庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- 添加html2canvas用於截圖 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- 添加Font Awesome圖標 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 添加 Litepicker 日期選擇器 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litepicker/dist/css/litepicker.css"/>
    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/litepicker.js"></script>
    <link rel="stylesheet" href="presentation.css">
    <script>
    // 偵測 iOS/Safari 並加上 is-ios-safari class
    (function() {
      var ua = window.navigator.userAgent;
      var isIOS = /iP(ad|hone|od)/.test(ua);
      var isSafari = /Safari/.test(ua) && !/Chrome/.test(ua);
      if (isIOS || isSafari) {
        document.addEventListener('DOMContentLoaded', function() {
          document.body.classList.add('is-ios-safari');
        });
      }
    })();
    </script>
</head>
<body>
    <div class="dashboard-header">
    <h1>智慧倉儲與銷售分析儀表板</h1>
        <div class="dashboard-subtitle">Smart Warehousing and Sales Analysis Dashboard</div>
    </div>

    <!-- 分頁導航 -->
    <div class="tab-nav">
        <button class="tab-link active" data-tab="inventory-tab">庫存</button>
        <button class="tab-link" data-tab="sales-tab">銷售</button>
    </div>

    <!-- 庫存視圖分頁 -->
    <div id="inventory-tab" class="tab-content active">
        <!-- 添加教學區塊 -->
        <div class="tutorial">
            <div class="tutorial-header">
                <div class="tutorial-title">
                    <i class="fas fa-book"></i>
                    <span>操作教學</span>
                </div>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="tutorial-content">
                <div class="tutorial-section">
                    <h3><i class="fas fa-sort"></i>資料排序</h3>
                    <ul>
                        <li><i class="fas fa-dollar-sign"></i>點擊「按月銷售額排序」可依據各機台的月銷售額高低排序</li>
                        <li><i class="fas fa-sort-amount-down"></i>點擊「庫存量由多到少」可查看庫存量較多的機台</li>
                        <li><i class="fas fa-sort-amount-up"></i>點擊「庫存量由少到多」可優先顯示需要補貨的機台</li>
                    </ul>
                </div>

                <div class="tutorial-section">
                    <h3><i class="fas fa-eye"></i>視圖切換</h3>
                    <ul>
                        <li><i class="fas fa-chart-pie"></i>圓餅圖視圖：直觀顯示各機台的庫存使用情況</li>
                        <li><i class="fas fa-table"></i>詳細資料視圖：查看完整的產品清單、地址及備註資訊</li>
                    </ul>
                </div>

                <div class="tutorial-section">
                    <h3><i class="fas fa-file-export"></i>匯出功能</h3>
                    <ul>
                        <li><i class="fas fa-file-code"></i>「另存為HTML」：保存為可離線查看的網頁檔案</li>
                        <li><i class="fas fa-camera"></i>「截圖保存」：將當前視圖儲存為圖片</li>
                        <li><i class="fas fa-print"></i>「列印」：列印當前視圖或儲存為PDF(該功能未完善，建議以截圖保存優先)</li>
                    </ul>
                </div>

                <div class="tutorial-section">
                    <h3><i class="fas fa-info-circle"></i>資料說明</h3>
                    <ul>
                        <li><i class="fas fa-box"></i>圓餅圖中的灰色部分代表機台剩餘可用空間</li>
                        <li><i class="fas fa-percentage"></i>使用量百分比顯示當前庫存佔總容量的比例</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="summary-info">
            <div id="summaryText">載入中...</div>
            <div id="salesSummaryText" style="margin-top: 8px; color: var(--primary-color); font-weight: 500;"></div>
        </div>
        
        <div class="toolbar">
             <div class="toolbar-section"> <!-- Left -->
                <button id="toggleViewModeButton" class="toolbar-button">
                    <i class="fas fa-table"></i>
                    <span class="tooltip">切換詳細資料視圖</span>
                </button>
                <button id="sortBySales" class="toolbar-button" data-sort="sales" data-active="false">
                    <i class="fas fa-dollar-sign"></i>
                    <span class="tooltip">按月銷售額排序</span>
                </button>
                <button id="sortByInventoryDesc" class="toolbar-button" data-sort="desc" data-active="false">
                    <i class="fas fa-sort-amount-down"></i>
                    <span class="tooltip">庫存量由多到少</span>
                </button>
                <button id="sortByInventoryAsc" class="toolbar-button" data-sort="asc" data-active="false">
                    <i class="fas fa-sort-amount-up"></i>
                    <span class="tooltip">庫存量由少到多</span>
                </button>
            </div>
            <div class="toolbar-section"> <!-- Right -->
                <input type="text" id="inventorySearchInput" class="search-input-presentation" placeholder="搜尋機台名稱/編號...">
                <button id="saveAsHtmlButton" class="toolbar-button">
                    <i class="fas fa-file-code"></i>
                    <span class="tooltip">另存為HTML</span>
                </button>
                <button id="captureButton" class="toolbar-button">
                    <i class="fas fa-camera"></i>
                    <span class="tooltip">截圖保存</span>
                </button>
                <button id="printButton" class="toolbar-button">
                    <i class="fas fa-print"></i>
                    <span class="tooltip">列印</span>
                </button>
            </div>
        </div>
        
        <div id="chartContainer">
            <div class="loading"></div>
        </div>
    </div>

    <!-- 補貨建議對話框 -->
    <div id="suggestionDialog" class="modal" style="display: none;">
        <div class="suggestion-modal-content">
            <span class="close">&times;</span>
            <h2 id="suggestionDialogTitle"><i class="fas fa-lightbulb"></i> 補貨建議</h2>
            
            <h4>1. 選擇補貨策略</h4>
            <div class="strategy-selector">
                <div class="strategy-card selected" data-strategy="stable">
                    <i class="fas fa-balance-scale-right"></i>
                    <h4>穩健銷售</h4>
                    <p>依據過去30天銷售量佔比，等比例分配庫存，確保穩定滿足市場需求。</p>
                </div>
                <div class="strategy-card" data-strategy="aggressive">
                    <i class="fas fa-rocket"></i>
                    <h4>積極增長</h4>
                    <p>集中80%庫存於銷量前3名的明星商品，最大化頂尖產品的營收潛力。</p>
                </div>
                <div class="strategy-card" data-strategy="exploratory">
                    <i class="fas fa-search-dollar"></i>
                    <h4>探索汰換</h4>
                    <p>優先汰除零銷量商品，並保留20%彈性空間，用於測試新品或補充潛力股。</p>
                </div>
            </div>

            <!-- 主要操作區 -->
            <div class="suggestion-controls">
                <button id="generateSuggestionButton" class="export-button generate-suggestion">
                    <i class="fas fa-magic"></i> 生成建議
                </button>
                <button id="toggleAdvancedOptionsButton" class="btn-info" type="button">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
            <div class="advanced-options-table" style="display:none;">
                <table>
                    <tr>
                        <td><i class="fas fa-box-open"></i></td>
                        <td class="adv-label">預留空位</td>
                        <td><input type="number" id="reserveSlotsInput" value="0" min="0" max="40" class="adv-input"></td>
                        <td class="adv-desc">保留給新品測試的空位數</td>
                    </tr>
                    <tr>
                        <td><i class="fas fa-plus-circle"></i></td>
                        <td class="adv-label">不取出現有產品</td>
                        <td><input type="checkbox" id="onlyAddCheckbox"></td>
                        <td class="adv-desc">僅補貨，不減少現有庫存</td>
                    </tr>
                    <tr>
                        <td><i class="fas fa-layer-group"></i></td>
                        <td class="adv-label">最大補貨總數量</td>
                        <td><input type="number" id="maxTotalQtyInput" value="50" min="1" max="50" class="adv-input"></td>
                        <td class="adv-desc">補貨後的總庫存上限</td>
                    </tr>
                </table>
            </div>
            <div id="suggestionWarning" style="color: #dc3545; font-size: 13px; margin: 8px 0 0 0; display: none;"></div>

            <h4>2. 建議結果</h4>
            <div id="suggestionResultContainer" class="suggestion-result-container">
                <p style="text-align: center; color: var(--text-secondary); padding: 20px;">請點擊 "生成建議" 以載入結果。</p>
            </div>
        </div>
    </div>

    <!-- 銷售趨勢分頁 -->
    <div id="sales-tab" class="tab-content">
        <div class="report-header">
            <h2 id="salesReportTitle" contenteditable="true" spellcheck="false"></h2>
            <button id="captureSalesTabButton" class="toolbar-button">
                <i class="fas fa-camera"></i>
                <span class="tooltip">截圖保存</span>
            </button>
        </div>
        
        <!-- KPI 儀表板 -->
        <div class="kpi-container">
            <div class="kpi-card">
                <h4>總銷售額</h4>
                <div id="kpi-total-sales" class="kpi-value-container">
                    <p>--</p>
                </div>
            </div>
            <div class="kpi-card">
                <h4>總交易筆數</h4>
                <div id="kpi-total-transactions" class="kpi-value-container">
                    <p>--</p>
                </div>
            </div>
            <div class="kpi-card">
                <h4>平均客單價</h4>
                <div id="kpi-avg-transaction-value" class="kpi-value-container">
                    <p>--</p>
                </div>
            </div>
        </div>

        <!-- 圖表切換器 -->
        <div class="chart-switcher">
            <button class="chart-switch-btn active" data-chart="daily">銷售趨勢</button>
            <button class="chart-switch-btn" data-chart="store">各分店銷售額</button>
            <button class="chart-switch-btn" data-chart="product">產品銷售佔比</button>
            <button class="chart-switch-btn" data-chart="payment">支付方式佔比</button>
        </div>

        <div class="sales-controls">
            <div class="control-group">
                <label for="datePicker" id="primaryPeriodLabel" contenteditable="true">主期間</label>:
                <input id="datePicker"/>
            </div>
            
            <div class="control-group">
                <label class="switch">
                    <input type="checkbox" id="compareToggle">
                    <span class="slider"></span>
                </label>
                <label for="compareToggle">對比</label>
            </div>

            <div class="control-group" id="compareDatePickerContainer">
                 <label for="compareDatePicker" id="comparePeriodLabel" contenteditable="true">對比期間</label>:
                 <input id="compareDatePicker"/>
            </div>
        </div>
        
        <!-- 時間單位切換器 -->
        <div id="timeUnitSwitcher" class="time-unit-switcher">
            <button class="time-unit-btn" data-unit="6h">每6小時</button>
            <button class="time-unit-btn active" data-unit="daily">每日</button>
            <button class="time-unit-btn" data-unit="2d">每2日</button>
        </div>
        
        <!-- 主圖表容器 -->
        <div class="main-chart-container">
            <canvas id="mainSalesChart"></canvas>
        </div>
    </div>


    <footer>
        <p>v3.0 | 任何問題請洽開發人員 <a href="https://line.me/ti/p/LwMjp6jZVH" target="_blank">徐</a></p>
    </footer>
    
    <!-- Screenshot Loader -->
    <div id="screenshotLoader" class="screenshot-loader" style="display: none;">
        <span>正在生成高解析度圖片...</span>
    </div>
    
    <script>
    window.chartGlassBg = 'rgba(255,255,255,0)'; // 預設全透明
        // 全局產品顏色映射表，確保跨所有圖表的一致性
        const globalProductColorMap = {};
        
        // 新增：從URL獲取參數的函數
        function getDataFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const updateTime = params.get('updateTime');
            if (updateTime) {
                // 將從URL獲取的時間存儲到全局變量
                window.updateTime = decodeURIComponent(updateTime);
            }
        }

        // 輔助函數：從本地存儲加載數據（支持分片） - 這部分將被重構
        async function loadAllData() {
            // --- Logging Start ---
            console.log('[Debug] Starting loadAllData...');
            // --- Logging End ---

            // 首先嘗試從URL獲取更新時間
            getDataFromUrl();

            // 優先使用內嵌數據 (用於另存為HTML)
            if (typeof window.embeddedData !== 'undefined') {
                console.log('使用內嵌數據');
                window.inventoryData = window.embeddedData;
                window.storeNotesAndAddresses = window.embeddedNotes || {};
                window.fullSalesData = window.embeddedFullSalesData || null;
                // ... 其他嵌入數據 ...
                if (window.embeddedColorMap) {
                     Object.assign(globalProductColorMap, window.embeddedColorMap);
                }
                return; // 返回 Promise.resolve() 的隱式結果
            }

            // --- API-driven data loading ---
            console.log('[Debug] Fetching data from server API...');
            try {
                // 並行獲取庫存和交易數據
                const [inventoryRes, transactionsRes] = await Promise.all([
                    fetch('/get-data'),
                    fetch('/api/transactions')
                ]);

                // --- Logging Start ---
                console.log('[Debug] API Response Status:', { inventory: inventoryRes.status, transactions: transactionsRes.status });
                if (!inventoryRes.ok) console.error('[Debug] Inventory response not OK:', await inventoryRes.text());
                if (!transactionsRes.ok) console.error('[Debug] Transactions response not OK:', await transactionsRes.text());
                // --- Logging End ---

                if (!inventoryRes.ok) throw new Error(`獲取庫存數據失敗: ${inventoryRes.statusText}`);
                const inventoryResult = await inventoryRes.json();
                
                // --- Logging Start ---
                console.log('[Debug] Parsed inventory data:', inventoryResult);
                // --- Logging End ---

                if (!inventoryResult.success) throw new Error(inventoryResult.message);
                
                if (!transactionsRes.ok) throw new Error(`獲取交易數據失敗: ${transactionsRes.statusText}`);
                window.fullSalesData = await transactionsRes.json();

                // --- NEW CENTRALIZED DATE PARSING ---
                if (window.fullSalesData) {
                    console.log('[Debug] loadAllData: Pre-parsing dates for fullSalesData...');
                    window.fullSalesData.forEach(d => {
                        if (d.date && typeof d.date === 'string') {
                            d.jsDate = new Date(d.date); // Simple and robust
                            if (isNaN(d.jsDate.getTime())) {
                                console.warn(`[Debug] Failed to parse date, setting to null. Original value:`, d.date);
                                d.jsDate = null;
                            }
                        } else {
                            d.jsDate = null;
                        }
                    });
                    console.log('[Debug] loadAllData: Date pre-parsing complete.');
                }
                // --- END ---

                // --- Logging Start ---
                console.log('[Debug] Parsed full sales data:', window.fullSalesData);
                // --- Logging End ---

                // 處理庫存數據
                const inventoryData = inventoryResult.data;
                window.inventoryData = inventoryData;

                // 從庫存數據中提取備註、地址和手動銷售額
                const notes = {};
                let latestProcessTime = 0;
                inventoryData.forEach(item => {
                    const storeKey = `${item.store}-${item.machineId}`;
                    if (!notes[storeKey]) {
                        notes[storeKey] = {
                            address: item.address,
                            note: item.note,
                            sales: item.manualSales || 0 // 恢復使用後端提供的銷售額
                        };
                    }
                    // 前端容錯：確保 processTime 總是被正確處理為 Date 物件
                    const processTimeValue = item.processTime ? new Date(item.processTime).getTime() : 0;
                    if (processTimeValue > latestProcessTime) {
                        latestProcessTime = processTimeValue;
                    }
                });
                window.storeNotesAndAddresses = notes;
                // --- Logging Start ---
                console.log('[Debug] Generated notes and addresses:', window.storeNotesAndAddresses);
                // --- Logging End ---

                if(latestProcessTime > 0) {
                     window.updateTime = new Date(latestProcessTime).toLocaleString('zh-TW');
                }
                 // 模擬舊版數據結構，以確保兼容性
                window.salesData = null; 
                window.selectedSalesMonth = null;
                
                console.log('[Debug] loadAllData finished successfully.');

            } catch (error) {
                console.error('[Debug] Error inside loadAllData:', error);
                // 可以在此處顯示錯誤訊息給用戶
                document.getElementById('chartContainer').innerHTML = `<p style="color: red;">加載數據失敗: ${error.message}</p>`;
                throw error; // 拋出錯誤以停止後續執行
            }
        }
        
        // 生成一致的顏色
        function generateConsistentColors(productNames) {
            const colors = [];
            
            // 預定義的顏色列表（明亮的顏色）
            const predefinedColors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
                '#FF9F40', '#8AC926', '#FF595E', '#1982C4', '#6A4C93',
                '#F94144', '#F3722C', '#F8961E', '#F9C74F', '#90BE6D',
                '#43AA8B', '#577590', '#277DA1', '#EF476F', '#FFD166'
            ];
            
            // 使用全局映射而非局部變量
            let colorIndex = Object.keys(globalProductColorMap).length;
            
            productNames.forEach(name => {
                if (!globalProductColorMap[name]) {
                    globalProductColorMap[name] = predefinedColors[colorIndex % predefinedColors.length];
                    colorIndex++;
                }
                
                colors.push(globalProductColorMap[name]);
            });
            
            return colors;
        }
        
        // 創建圓餅圖
        function createDonutChart(storeKey, products) {
            const chartElement = document.getElementById(`chart-${storeKey}`);
            if (!chartElement) {
                console.error(`找不到圖表元素: chart-${storeKey}`);
                return;
            }
            
            try {
                // 檢查是否已經有圖表實例，如果有則銷毀
                const existingChart = Chart.getChart(chartElement);
                if (existingChart) {
                    existingChart.destroy();
                }
                
                // 計算總數量
                let totalQuantity = 0;
                products.forEach(product => {
                    totalQuantity += product.quantity;
                });
                
                // 機台容量上限
                const maxCapacity = 50;
                const remainingCapacity = Math.max(0, maxCapacity - totalQuantity);
                
                // 準備數據
                const data = {
                    labels: [...products.map(p => p.name), '空位'],
                    datasets: [{
                        data: [...products.map(p => p.quantity), remainingCapacity],
                        backgroundColor: generateConsistentColors(products.map(p => p.name)).concat(['#e0e0e0']), // 最後一個顏色是灰色，代表空位
                        borderWidth: 1
                    }]
                };
                
                // 創建圓餅圖
                new Chart(chartElement, {
                    type: 'doughnut',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const percentage = Math.round((value / maxCapacity) * 100);
                                        return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                            },
                            glassmorphismBackground: true
                        },
                        cutout: '70%'
                    }
                });
                
                console.log(`成功創建圖表: chart-${storeKey}`);
            } catch (error) {
                console.error(`創建圓餅圖失敗 ${storeKey}:`, error);
            }
        }
        
        // 顯示圓餅圖
        function displayCharts(data) {
            // --- Logging Start ---
            console.log('[Debug] displayCharts called with data:', data);
            // --- Logging End ---
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.innerHTML = '';
            
            if (!data || data.length === 0) {
                chartContainer.innerHTML = '<p>沒有數據可顯示</p>';
                return;
            }

            // --- NEW: Calculate last 30 days sales data ---
            let last30DaysSalesData = {};
            let salesDateRangeText = '未加載銷售數據，無法計算排名。';

            if (window.fullSalesData && window.fullSalesData.length > 0) {
                const validDates = window.fullSalesData.map(d => d.jsDate).filter(Boolean);
                if (validDates.length > 0) {
                    // 1. Find the latest transaction date
                    const latestDate = new Date(Math.max(...validDates));
                    
                    // 2. Calculate the 30-day window
                    const endDate = new Date(latestDate);
                    const startDate = new Date(latestDate);
                    startDate.setDate(startDate.getDate() - 29); // 30 days inclusive
                    startDate.setHours(0, 0, 0, 0);
                    endDate.setHours(23, 59, 59, 999);

                    const formatDate = (date) => `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
                    salesDateRangeText = `顯示過去一個月 (${formatDate(startDate)} - ${formatDate(endDate)}) 的銷售數據。`;

                    // 3. Filter transactions within this window
                    const recentSales = window.fullSalesData.filter(d => 
                        d.jsDate && d.jsDate >= startDate && d.jsDate <= endDate
                    );

                    // 4. Aggregate the data
                    const aggregatedSales = {};
                    recentSales.forEach(sale => {
                        if (!sale.shopName || !sale.product) return;

                        const shopName = String(sale.shopName).trim();
                        const productName = String(sale.product).trim();

                        if (!aggregatedSales[shopName]) {
                            aggregatedSales[shopName] = {};
                        }
                        if (!aggregatedSales[shopName][productName]) {
                            aggregatedSales[shopName][productName] = { count: 0, lastSoldDate: '1970-01-01' };
                        }

                        aggregatedSales[shopName][productName].count++;
                        
                        // Add sales amount to the store's total
                        if (!aggregatedSales[shopName].totalSales) {
                            aggregatedSales[shopName].totalSales = 0;
                        }
                        aggregatedSales[shopName].totalSales += parseFloat(sale.amount) || 0;

                        const saleDateStr = sale.jsDate.toISOString().split('T')[0];
                        if (saleDateStr > aggregatedSales[shopName][productName].lastSoldDate) {
                            aggregatedSales[shopName][productName].lastSoldDate = saleDateStr;
                        }
                    });
                    last30DaysSalesData = aggregatedSales;
                }
            }
            
            // 對數據進行預處理，根據後端提供的 isHidden 標誌過濾數據
            const cleanedData = data.filter(item => !item.isHidden);
            
            // 按機台分組
            const storeGroups = {};
            cleanedData.forEach(item => {
                const storeKey = `${item.store}-${item.machineId}`;
                if (!storeGroups[storeKey]) {
                    storeGroups[storeKey] = {
                        store: item.store,
                        machineId: item.machineId,
                        lastUpdated: item.lastUpdated,
                        lastCleaned: item.lastCleaned,
                        products: [],
                        totalQuantity: 0 // 添加總數量欄位
                    };
                }
                
                // 檢查是否已經添加過相同的產品
                const existingProduct = storeGroups[storeKey].products.find(p => p.name === item.productName);
                if (!existingProduct) {
                    storeGroups[storeKey].products.push({
                        name: item.productName,
                        quantity: item.quantity
                    });
                    // 累計總數量
                    storeGroups[storeKey].totalQuantity += item.quantity;
                }
            });
            
            // 使用全局備註數據
            const storeNotesAndAddresses = window.storeNotesAndAddresses || {};
            
            // 將storeGroups轉換為數組以便排序
            let storeGroupsArray = Object.entries(storeGroups).map(([key, value]) => {
                // 獲取銷售額 - 改為使用動態計算的過去一個月銷售額
                const machineSalesTotal = last30DaysSalesData[value.store] ? last30DaysSalesData[value.store].totalSales : 0;
                // 新增：計算該機台過去一個月銷售份數
                let machineSalesCount = 0;
                if (last30DaysSalesData[value.store]) {
                    // 將所有產品的 count 相加
                    machineSalesCount = Object.values(last30DaysSalesData[value.store])
                        .filter(v => typeof v === 'object' && v.count !== undefined)
                        .reduce((sum, v) => sum + (v.count || 0), 0);
                }
                return {
                    key,
                    ...value,
                    salesAmount: machineSalesTotal,
                    salesCount: machineSalesCount
                };
            });
            
            // --- 新的排序和篩選邏輯 ---
            let fullStoreGroupsArray = [...storeGroupsArray];
            let currentInventorySort = { key: null, order: 'desc' }; // key: 'salesAmount', 'totalQuantity'

            function applyInventoryFiltersAndRender() {
                let dataToRender = [...fullStoreGroupsArray];
                const searchTerm = document.getElementById('inventorySearchInput').value.toLowerCase();

                // 1. 篩選
                if (searchTerm) {
                    dataToRender = dataToRender.filter(item => 
                        item.store.toLowerCase().includes(searchTerm) || 
                        item.machineId.toLowerCase().includes(searchTerm)
                    );
                }

                // 2. 排序
                if (currentInventorySort.key) {
                    dataToRender.sort((a, b) => {
                        const valA = a[currentInventorySort.key];
                        const valB = b[currentInventorySort.key];
                        const comparison = valA > valB ? -1 : (valA < valB ? 1 : 0);
                        return currentInventorySort.order === 'desc' ? comparison : -comparison;
                    });
                }
                
                renderStoreCards(dataToRender, storeNotesAndAddresses, last30DaysSalesData);
                updateSortButtonsState(currentInventorySort.key ? `sortBy${currentInventorySort.key}` : null);
            }
            
            // 添加排序和篩選事件監聽器
            document.getElementById('inventorySearchInput').addEventListener('input', applyInventoryFiltersAndRender);

            document.getElementById('sortBySales').addEventListener('click', function() {
                currentInventorySort = { key: 'salesAmount', order: 'desc' };
                applyInventoryFiltersAndRender();
                updateSortButtonsState('sortBySales');
            });
            
            document.getElementById('sortByInventoryDesc').addEventListener('click', function() {
                currentInventorySort = { key: 'totalQuantity', order: 'desc' };
                applyInventoryFiltersAndRender();
                updateSortButtonsState('sortByInventoryDesc');
            });
            
            document.getElementById('sortByInventoryAsc').addEventListener('click', function() {
                currentInventorySort = { key: 'totalQuantity', order: 'asc' };
                applyInventoryFiltersAndRender();
                updateSortButtonsState('sortByInventoryAsc');
            });
            
            // 初始渲染
            applyInventoryFiltersAndRender();
            
            // 更新摘要信息
            const summaryText = document.getElementById('summaryText');
            const updateTime = window.updateTime || '未設定';
            summaryText.innerHTML = `共有 ${storeGroupsArray.length} 個機台的庫存數據，總計 ${cleanedData.length} 項產品數據<br>更新時間: ${updateTime}`;

            const salesSummaryText = document.getElementById('salesSummaryText');
            salesSummaryText.textContent = salesDateRangeText;
        }
        
        // --- 新的銷售趨勢圖表邏輯 ---
        let mainSalesChartInstance = null;
        let datePickerInstance = null;
        let compareDatePickerInstance = null;
        let isCompareMode = false;
        let activeSalesChart = 'daily'; // 追蹤當前活動的圖表
        let activeTimeUnit = 'daily'; // 新增：追蹤當前時間單位
        let currentChartData = {}; // 存儲已聚合的數據
        
        // 新增: 過濾數據的輔助函數
        function filterDataByDateRange(data, startDate, endDate) {
            if (!startDate || !endDate) return [];
            
            // 修正：將結束日期調整為當天的結束時間，以包含整天
            const adjustedEndDate = new Date(endDate);
            adjustedEndDate.setHours(23, 59, 59, 999);

            return data.filter(d => {
                const amount = parseFloat(d.amount) || 0;
                // 新增：過濾掉0元或負數的交易
                if (amount <= 0) return false;
                
                const isWithinRange = d.jsDate && d.jsDate >= startDate && d.jsDate <= adjustedEndDate;
                
                return isWithinRange;
            });
        }

        function setupSalesTrendTab(fullSalesData) {
            // --- Logging Start ---
            console.log('[Debug] setupSalesTrendTab called with data:', fullSalesData);
            // --- Logging End ---
            if (!fullSalesData || fullSalesData.length === 0) {
                document.getElementById('sales-tab').innerHTML = '<p style="text-align: center;">沒有銷售數據可供分析。</p>';
                return;
            }
            
            // The date parsing logic has been moved to loadAllData() to ensure it's globally available.
            // This function can now assume that fullSalesData contains processed jsDate properties.

            // 初始化日期選擇器
            datePickerInstance = new Litepicker({
                element: document.getElementById('datePicker'),
                singleMode: false,
                format: 'YYYY-MM-DD',
                setup: (picker) => {
                    picker.on('selected', (date1, date2) => {
                        processAndRenderCharts(fullSalesData, date1.dateInstance, date2.dateInstance);
                    });
                }
            });

            // 初始化對比日期選擇器
            compareDatePickerInstance = new Litepicker({
                element: document.getElementById('compareDatePicker'),
                singleMode: false,
                format: 'YYYY-MM-DD',
                 setup: (picker) => {
                    picker.on('selected', (date1, date2) => {
                        // 只需要重新渲染，不需要重新聚合數據
                        renderActiveChart();
                    });
                }
            });
            
            // 初始化對比開關
            const compareToggle = document.getElementById('compareToggle');
            const compareContainer = document.getElementById('compareDatePickerContainer');
            const compareInput = document.getElementById('compareDatePicker');
            
            // 初始化禁用狀態
            compareContainer.classList.add('disabled');
            compareInput.disabled = true;

            compareToggle.addEventListener('change', (e) => {
                isCompareMode = e.target.checked;
                
                if (isCompareMode) {
                    compareContainer.classList.remove('disabled');
                    compareInput.disabled = false;
                } else {
                    compareContainer.classList.add('disabled');
                    compareInput.disabled = true;
                }
                
                // 如果開啟對比且對比日期未設定，則設定一個預設值
                if (isCompareMode && !compareDatePickerInstance.getStartDate()) {
                    const primaryStart = datePickerInstance.getStartDate().dateInstance;
                    const primaryEnd = datePickerInstance.getEndDate().dateInstance;
                    const duration = (primaryEnd - primaryStart) / (1000 * 60 * 60 * 24);
                    
                    const compareEndDate = new Date(primaryStart);
                    compareEndDate.setDate(compareEndDate.getDate() - 1);
                    const compareStartDate = new Date(compareEndDate);
                    compareStartDate.setDate(compareStartDate.getDate() - duration);

                    compareDatePickerInstance.setDateRange(compareStartDate, compareEndDate);
                }
                
                renderActiveChart();
            });

            // 初始化圖表切換按鈕
            document.querySelectorAll('.chart-switch-btn').forEach(button => {
                button.addEventListener('click', () => {
                    activeSalesChart = button.dataset.chart;
                    document.querySelectorAll('.chart-switch-btn').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // 新增：根據圖表類型顯示/隱藏時間單位切換器
                    const timeUnitSwitcher = document.getElementById('timeUnitSwitcher');
                    if (activeSalesChart === 'daily') {
                        timeUnitSwitcher.classList.remove('hidden');
                    } else {
                        timeUnitSwitcher.classList.add('hidden');
                    }

                    renderActiveChart(); // 使用已有的數據重新渲染
                });
            });

            // 新增：初始化時間單位切換按鈕
            document.querySelectorAll('.time-unit-btn').forEach(button => {
                button.addEventListener('click', () => {
                    activeTimeUnit = button.dataset.unit;
                    document.querySelectorAll('.time-unit-btn').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    renderActiveChart();
                });
            });

            // 預設顯示最近一個月的數據
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(endDate.getDate() - 29);
            datePickerInstance.setDateRange(startDate, endDate);
            
            // 首次加載時觸發數據處理與圖表渲染
            processAndRenderCharts(fullSalesData, startDate, endDate);
        }
        
        function processAndRenderCharts(fullSalesData, startDate, endDate) {
            // 1. 篩選主期間數據 (使用新的輔助函數，已包含0元過濾和日期修正)
            const primaryFilteredData = filterDataByDateRange(fullSalesData, startDate, endDate);

            // --- 新增詳細日誌 ---
            console.log('[Debug] processAndRenderCharts:');
            // Use a timezone-neutral format for logging to avoid confusion
            const toLocalISOString = (date) => new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
            console.log(`[Debug] Date Range Selected (Local): ${toLocalISOString(startDate)} to ${toLocalISOString(endDate)}`);
            console.log(`[Debug] Total items from server: ${fullSalesData.length}`);
            console.log(`[Debug] Filtered data count for this range: ${primaryFilteredData.length}`);
            if (primaryFilteredData.length > 0) {
                 console.log('[Debug] First item in filtered data:', primaryFilteredData[0]);
            } else {
                 console.log('[Debug] No data matched the selected date range.');
            }
            // --- 日誌結束 ---

            // 2. 聚合主期間數據
            const primaryData = aggregateData(primaryFilteredData);
            
            // 存儲聚合後的數據，包括已篩選的原始數據以供KPI使用
            currentChartData = { 
                primary: primaryData,
                primaryFiltered: primaryFilteredData
            };

            // 3. 繪製當前活動的圖表 (KPI渲染將在此函數中完成)
            renderActiveChart();
        }

        // 新增: 聚合數據的輔助函數
        function aggregateData(filteredData) {
            const dailyData = {};
            const storeData = {};
            const productData = {};
            const paymentData = {};
            const uniqueShops = new Set(); 

            filteredData.forEach(d => {
                const amount = parseFloat(d.amount) || 0;
                
                const y = d.jsDate.getFullYear();
                const m = String(d.jsDate.getMonth() + 1).padStart(2, '0');
                const day = String(d.jsDate.getDate()).padStart(2, '0');
                const fullDate = `${y}-${m}-${day}`;
                
                if (!dailyData[fullDate]) dailyData[fullDate] = 0;
                dailyData[fullDate] += amount;

                if (d.shopName) { // 增加一個檢查確保 shopName 存在
                    const shopName = String(d.shopName).trim(); // 標準化店鋪名稱
                    if (!storeData[shopName]) storeData[shopName] = 0;
                    storeData[shopName] += amount;
                    uniqueShops.add(shopName);
                }

                if (!productData[d.product]) productData[d.product] = 0;
                productData[d.product] += amount;

                if (!paymentData[d.payType]) paymentData[d.payType] = 0;
                paymentData[d.payType]++;
            });

            console.log(`[Debug] aggregateData: Found ${uniqueShops.size} unique shops.`);
            console.log('[Debug] Final aggregated storeData for chart:', storeData);
            
            return { dailyData, storeData, productData, paymentData };
        }

        function updateKpiCard(containerId, primaryValue, compareValue, isComparing, unit = '', isCurrency = true) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const formatOptions = isCurrency ? { maximumFractionDigits: 0 } : {};

            let innerHTML = `<p>${primaryValue.toLocaleString('en-US', formatOptions)}${unit}</p>`;

            // 只有在啟用比較模式且比較值大於0時才顯示差異
            if (isComparing && compareValue > 0) {
                const difference = primaryValue - compareValue;
                const percentageChange = (difference / compareValue) * 100;
                
                const arrow = difference >= 0 ? '▲' : '▼';
                const colorClass = difference >= 0 ? 'positive' : 'negative';
                const sign = difference >= 0 ? '+' : '';
                const tooltipText = `與對比期間相差: ${sign}${difference.toLocaleString('en-US', formatOptions)}${unit}`;

                innerHTML += `
                    <span class="kpi-comparison ${colorClass}" title="${tooltipText}">
                        ${arrow} ${percentageChange.toFixed(1)}%
                    </span>
                `;
            }

            container.innerHTML = innerHTML;
        }

        function renderActiveChart() {
            if (mainSalesChartInstance) {
                mainSalesChartInstance.destroy();
            }

            // --- 1. KPI Calculation & Rendering ---
            const primaryFiltered = currentChartData.primaryFiltered || [];
            const primaryTotalSales = primaryFiltered.reduce((sum, d) => sum + (parseFloat(d.amount) || 0), 0);
            const primaryTotalTransactions = primaryFiltered.length;
            const primaryAvgTransactionValue = primaryTotalTransactions > 0 ? primaryTotalSales / primaryTotalTransactions : 0;
            
            let compareFilteredData = [];
            let comparisonIsActive = false;

            if (isCompareMode) {
                const compareStart = compareDatePickerInstance.getStartDate()?.dateInstance;
                const compareEnd = compareDatePickerInstance.getEndDate()?.dateInstance;

                if (compareStart && compareEnd) {
                    comparisonIsActive = true;
                    const fullSalesData = window.fullSalesData || [];
                    compareFilteredData = filterDataByDateRange(fullSalesData, compareStart, compareEnd);
                }
            }

            const compareTotalSales = compareFilteredData.reduce((sum, d) => sum + (parseFloat(d.amount) || 0), 0);
            const compareTotalTransactions = compareFilteredData.length;
            const compareAvgTransactionValue = compareTotalTransactions > 0 ? compareTotalSales / compareTotalTransactions : 0;
            
            updateKpiCard('kpi-total-sales', primaryTotalSales, compareTotalSales, comparisonIsActive, ' 元', true);
            updateKpiCard('kpi-total-transactions', primaryTotalTransactions, compareTotalTransactions, comparisonIsActive, ' 筆', false);
            updateKpiCard('kpi-avg-transaction-value', primaryAvgTransactionValue, compareAvgTransactionValue, comparisonIsActive, ' 元', true);


            // --- 2. Chart Data Aggregation ---
            // The main data is already filtered. We just need to aggregate comparison data if active.
            if (comparisonIsActive) {
                 currentChartData.comparison = aggregateData(compareFilteredData);
                 currentChartData.comparisonFiltered = compareFilteredData;
            } else {
                delete currentChartData.comparison;
                delete currentChartData.comparisonFiltered;
            }

            // --- 3. Chart Rendering ---
            switch (activeSalesChart) {
                case 'daily':
                    renderDailySalesChart();
                    break;
                case 'store':
                    renderStoreSalesChart(
                        currentChartData.primary.storeData,
                        comparisonIsActive ? currentChartData.comparison?.storeData : null
                    );
                    break;
                case 'product':
                    renderProductSalesChart(
                        currentChartData.primary.productData,
                        comparisonIsActive ? currentChartData.comparison?.productData : null
                    );
                    break;
                case 'payment':
                    renderPaymentTypeChart(
                        currentChartData.primary.paymentData,
                        comparisonIsActive ? currentChartData.comparison?.paymentData : null
                    );
                    break;
            }
        }

        function aggregateByTimeUnit(data, unit, periodStartDate, periodEndDate) {
            const labels = [];
            const values = [];
            if (!data || data.length === 0 || !periodStartDate || !periodEndDate) {
                return { labels, values };
            }
            
            const formatShortDate = (d) => `${d.getMonth() + 1}/${d.getDate()}`;

            let bucketStart = new Date(periodStartDate);
            
            // 確保起始時間是從0點開始
            if (unit !== '6h') {
                bucketStart.setHours(0, 0, 0, 0);
            }

            while (bucketStart <= periodEndDate) {
                let bucketEnd;
                let label;
                let nextBucketStart = new Date(bucketStart);

                switch (unit) {
                    case '6h':
                        bucketEnd = new Date(bucketStart.getTime() + (6 * 60 * 60 * 1000) - 1);
                        nextBucketStart.setHours(nextBucketStart.getHours() + 6);
                        const hour = bucketStart.getHours();
                        if (hour >= 0 && hour < 6) {
                            label = `${formatShortDate(bucketStart)}`;
                        } else if (hour >= 6 && hour < 12) {
                            label = '早上';
                        } else if (hour >= 12 && hour < 18) {
                            label = '中午';
                        } else { // 18-24
                            label = '晚上';
                        }
                        break;
                    case '2d':
                        nextBucketStart.setDate(nextBucketStart.getDate() + 2);
                        bucketEnd = new Date(nextBucketStart.getTime() - 1);
                        label = formatShortDate(bucketStart);
                        break;
                    default: // 'daily'
                        nextBucketStart.setDate(nextBucketStart.getDate() + 1);
                        bucketEnd = new Date(nextBucketStart.getTime() - 1);
                        label = formatShortDate(bucketStart);
                        break;
                }
                
                // 確保最後一個 bucket 不會超過期間結束日期
                if (bucketEnd > periodEndDate) {
                    bucketEnd = new Date(periodEndDate);
                }

                const amountInBucket = data
                    .filter(d => d.jsDate >= bucketStart && d.jsDate <= bucketEnd)
                    .reduce((sum, d) => sum + (parseFloat(d.amount) || 0), 0);
                
                labels.push(label);
                values.push(amountInBucket);

                bucketStart = nextBucketStart;
                if(bucketStart > periodEndDate) break;
            }

            return { labels, values };
        }

        function renderDailySalesChart() {
            // 從 currentChartData 獲取數據
            const primaryStartDate = datePickerInstance.getStartDate().dateInstance;
            const primaryEndDate = datePickerInstance.getEndDate().dateInstance;
            const primaryFiltered = currentChartData.primaryFiltered || [];
            
            const adjustedPrimaryEndDate = new Date(primaryEndDate);
            adjustedPrimaryEndDate.setHours(23, 59, 59, 999);
            
            const primaryAgg = aggregateByTimeUnit(primaryFiltered, activeTimeUnit, primaryStartDate, adjustedPrimaryEndDate);

            let compareAgg = null;
            if (isCompareMode && currentChartData.comparisonFiltered) {
                const compareStartDate = compareDatePickerInstance.getStartDate().dateInstance;
                const compareEndDate = compareDatePickerInstance.getEndDate().dateInstance;
                const adjustedCompareEndDate = new Date(compareEndDate);
                adjustedCompareEndDate.setHours(23, 59, 59, 999);
                compareAgg = aggregateByTimeUnit(currentChartData.comparisonFiltered, activeTimeUnit, compareStartDate, adjustedCompareEndDate);
            }

            const maxLen = Math.max(primaryAgg.values.length, compareAgg ? compareAgg.values.length : 0);
            const labels = Array.from({ length: maxLen }, (_, i) => i + 1);

            const primaryDataset = [...primaryAgg.values, ...Array(maxLen - primaryAgg.values.length).fill(0)];

            const primaryLabel = document.getElementById('primaryPeriodLabel').textContent;
            const compareLabel = document.getElementById('comparePeriodLabel').textContent;

            const datasets = [{
                label: primaryLabel,
                data: primaryDataset,
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                fill: true,
                tension: 0,
                borderWidth: 2,
                pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                pointRadius: 3,
                pointHoverRadius: 5
            }];

            if (compareAgg) {
                const comparisonDataset = [...compareAgg.values, ...Array(maxLen - compareAgg.values.length).fill(0)];
                datasets.push({
                    label: compareLabel,
                    data: comparisonDataset,
                    borderColor: 'rgba(170, 170, 170, 1)',
                    backgroundColor: 'rgba(170, 170, 170, 0.2)',
                    fill: true,
                    tension: 0,
                    borderDash: [5, 5],
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(170, 170, 170, 1)',
                    pointRadius: 3,
                    pointHoverRadius: 5
                });
            }

            const ctx = document.getElementById('mainSalesChart').getContext('2d');
            mainSalesChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                           title: {
                               display: true,
                               text: `時間單位: ${activeTimeUnit}`
                           },
                           ticks: {
                               callback: function(value, index, ticks) {
                                   // `value` is the tick value. For a category axis, this is the index.
                                   const label = primaryAgg.labels[index];
                                   if (!label) return ''; // Avoid errors

                                   if (activeTimeUnit === '2d') {
                                       return index % 2 === 0 ? label : '';
                                   }
                                   
                                   return label;
                               },
                               autoSkip: false,
                               maxRotation: 0
                           }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString() + ' 元';
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                           display: true, // 顯示圖例以便區分
                           position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const periodIndex = context[0].label;
                                    return `第 ${periodIndex} 區間`;
                                },
                                afterTitle: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    let footer = '';
                                    if(primaryAgg.labels[dataIndex]){
                                        footer += `${primaryLabel}: ${primaryAgg.labels[dataIndex]}\n`;
                                    }
                                    if(compareAgg && compareAgg.labels[dataIndex]){
                                        footer += `${compareLabel}: ${compareAgg.labels[dataIndex]}`;
                                    }
                                    return footer.trim();
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    let value = context.parsed.y || 0;
                                    return `${label}: ${value.toLocaleString()} 元`;
                                }
                            }
                        },
                        glassmorphismBackground: true
                    }
                }
            });
        }
        
        function renderStoreSalesChart(primaryData, compareData) {
            // Get all unique store names from both periods
            const primaryStores = Object.keys(primaryData || {});
            const compareStores = Object.keys(compareData || {});
            const allStoreNames = [...new Set([...primaryStores, ...compareStores])];

            // Sort stores by primary period sales amount, descending.
            allStoreNames.sort((a, b) => (primaryData[b] || 0) - (primaryData[a] || 0));

            const primaryLabel = document.getElementById('primaryPeriodLabel').textContent;
            const compareLabel = document.getElementById('comparePeriodLabel').textContent;

            const datasets = [
                {
                    label: primaryLabel,
                    data: allStoreNames.map(storeName => primaryData[storeName] || 0),
                    backgroundColor: 'rgba(54, 162, 235, 0.8)', // Primary color
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }
            ];

            if (compareData) {
                datasets.push({
                    label: compareLabel,
                    data: allStoreNames.map(storeName => compareData[storeName] || 0),
                    backgroundColor: 'rgba(170, 170, 170, 0.7)', // Comparison color
                    borderColor: 'rgba(170, 170, 170, 1)',
                    borderWidth: 1
                });
            }
            
            const ctx = document.getElementById('mainSalesChart').getContext('2d');
            mainSalesChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: allStoreNames, // Use the combined list of store names
                    datasets: datasets      // Use the new datasets array
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { callback: value => value.toLocaleString() + ' 元' }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: compareData ? true : false, // Show legend only when comparing
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    let value = context.parsed.y || 0;
                                    return `${label}: ${value.toLocaleString()} 元`;
                                }
                            }
                        },
                        glassmorphismBackground: true
                    }
                }
            });
        }

        function renderProductSalesChart(primaryData, compareData) {
            if (!primaryData) return;

            const ctx = document.getElementById('mainSalesChart').getContext('2d');

            // --- Comparison Mode: 100% Stacked Bar Chart ---
            if (compareData) {
                const process = (data) => {
                    const sorted = Object.entries(data || {}).sort(([, a], [, b]) => b - a);
                    const topN = 10;
                    const topItems = sorted.slice(0, topN);
                    const otherAmount = sorted.slice(topN).reduce((sum, [, amount]) => sum + amount, 0);
                    let processedData = Object.fromEntries(topItems);
                    if (otherAmount > 0) processedData['其他'] = otherAmount;
                    return processedData;
                };
                
                const processedPrimary = process(primaryData);
                const processedCompare = process(compareData);

                const totalPrimary = Object.values(processedPrimary).reduce((sum, v) => sum + v, 0);
                const totalCompare = Object.values(processedCompare).reduce((sum, v) => sum + v, 0);

                const allProductLabels = [...new Set([...Object.keys(processedPrimary), ...Object.keys(processedCompare)])];
                
                const datasets = allProductLabels.map(label => {
                    const primaryValue = processedPrimary[label] || 0;
                    const compareValue = processedCompare[label] || 0;
                    const primaryPercentage = totalPrimary > 0 ? (primaryValue / totalPrimary) * 100 : 0;
                    const comparePercentage = totalCompare > 0 ? (compareValue / totalCompare) * 100 : 0;

                    return {
                        label: label,
                        data: [primaryPercentage, comparePercentage],
                        backgroundColor: generateConsistentColors([label])[0],
                        originalValues: [primaryValue, compareValue] // Store for tooltip
                    };
                });

                const primaryLabel = document.getElementById('primaryPeriodLabel').textContent;
                const compareLabel = document.getElementById('comparePeriodLabel').textContent;

                mainSalesChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [primaryLabel, compareLabel],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                max: 100,
                                ticks: { callback: value => value.toFixed(0) + '%' }
                            }
                        },
                        plugins: {
                            legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const dataset = context.chart.data.datasets[context.datasetIndex];
                                        const originalValue = dataset.originalValues[context.dataIndex];
                                        const percentage = context.parsed.y;
                                        return `${dataset.label}: ${originalValue.toLocaleString()} 元 (${percentage.toFixed(1)}%)`;
                                    }
                                }
                            },
                            glassmorphismBackground: true
                        }
                    }
                });
                return;
            }

            // --- Default Mode: Doughnut Chart ---
            const sortedProducts = Object.entries(primaryData).sort(([,a],[,b]) => b-a);
            const topN = 10;
            const topProducts = sortedProducts.slice(0, topN);
            const otherAmount = sortedProducts.slice(topN).reduce((sum, [, amount]) => sum + amount, 0);

            const labels = topProducts.map(([name]) => name);
            const data = topProducts.map(([,amount]) => amount);
            if (otherAmount > 0) {
                labels.push('其他');
                data.push(otherAmount);
            }

            mainSalesChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: generateConsistentColors(labels)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12 } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    let value = context.raw || 0;
                                    const total = context.chart.getDatasetMeta(0).total;
                                    const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;
                                    return `${label}: ${value.toLocaleString()} 元 (${percentage}%)`;
                                }
                            }
                        },
                        glassmorphismBackground: true
                    }
                }
            });
        }

        function renderPaymentTypeChart(primaryData, compareData) {
            if (!primaryData) return;

            const ctx = document.getElementById('mainSalesChart').getContext('2d');

             // --- Comparison Mode: 100% Stacked Bar Chart ---
            if (compareData) {
                const totalPrimary = Object.values(primaryData).reduce((sum, v) => sum + v, 0);
                const totalCompare = Object.values(compareData).reduce((sum, v) => sum + v, 0);

                const allPaymentLabels = [...new Set([...Object.keys(primaryData), ...Object.keys(compareData)])];

                const datasets = allPaymentLabels.map(label => {
                    const primaryValue = primaryData[label] || 0;
                    const compareValue = compareData[label] || 0;
                    const primaryPercentage = totalPrimary > 0 ? (primaryValue / totalPrimary) * 100 : 0;
                    const comparePercentage = totalCompare > 0 ? (compareValue / totalCompare) * 100 : 0;

                    return {
                        label: label,
                        data: [primaryPercentage, comparePercentage],
                        backgroundColor: generateConsistentColors([label])[0],
                        originalValues: [primaryValue, compareValue]
                    };
                });

                const primaryLabel = document.getElementById('primaryPeriodLabel').textContent;
                const compareLabel = document.getElementById('comparePeriodLabel').textContent;

                mainSalesChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [primaryLabel, compareLabel],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                max: 100,
                                ticks: { callback: value => value.toFixed(0) + '%' }
                            }
                        },
                        plugins: {
                            legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const dataset = context.chart.data.datasets[context.datasetIndex];
                                        const originalValue = dataset.originalValues[context.dataIndex];
                                        const percentage = context.parsed.y;
                                        return `${dataset.label}: ${originalValue.toLocaleString()} 筆 (${percentage.toFixed(1)}%)`;
                                    }
                                }
                            },
                            glassmorphismBackground: true
                        }
                    }
                });
                return;
            }

            // --- Default Mode: Pie Chart ---
            const labels = Object.keys(primaryData);
            const data = Object.values(primaryData);

            mainSalesChartInstance = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: generateConsistentColors(labels)
                    }]
                },
                 options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12 } },
                         tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    let value = context.raw || 0;
                                    const total = context.chart.getDatasetMeta(0).total;
                                    const percentage = total > 0 ? (value / total * 100).toFixed(1) : 0;
                                    return `${label}: ${value.toLocaleString()} 筆 (${percentage}%)`;
                                }
                            }
                        },
                        glassmorphismBackground: true
                    }
                }
            });
        }

        // 更新排序按鈕狀態
        function updateSortButtonsState(activeButtonId) {
            document.querySelectorAll('.toolbar-button[data-sort]').forEach(button => {
                button.setAttribute('data-active', 'false');
            });
            if (activeButtonId) {
                const buttonElement = document.getElementById(activeButtonId);
                if (buttonElement) {
                    buttonElement.setAttribute('data-active', 'true');
                }
            }
        }
        
        // 渲染機台卡片
        function renderStoreCards(storeGroupsArray, storeNotesAndAddresses, salesData) {
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.innerHTML = '';
            
            storeGroupsArray.forEach(({ key, store, machineId, lastUpdated, lastCleaned, products, totalQuantity }) => {
                const noteData = storeNotesAndAddresses[key] || { address: '', note: '', sales: 0 };
                const maxCapacity = 50;
                const usagePercentage = Math.min(Math.round((totalQuantity / maxCapacity) * 100), 100);
                
                // 新增：對日期進行防禦性檢查
                const lastUpdatedText = lastUpdated ? lastUpdated.split(' ')[0] : 'N/A';
                const lastCleanedText = lastCleaned ? lastCleaned.split(' ')[0] : 'N/A';
                
                // --- NEW: Get the last 30 days sales for this specific store ---
                const machineSalesTotal = salesData[store] ? salesData[store].totalSales : 0;
                // 新增：計算該機台過去一個月銷售份數
                let machineSalesCount = 0;
                if (salesData[store]) {
                    // 將所有產品的 count 相加
                    machineSalesCount = Object.values(salesData[store])
                        .filter(v => typeof v === 'object' && v.count !== undefined)
                        .reduce((sum, v) => sum + (v.count || 0), 0);
                }
                
                // 創建卡片
                const cardDiv = document.createElement('div');
                cardDiv.className = 'chart-card';
                cardDiv.id = `card-${key}`;
                
                // 圓餅圖視圖內容
                cardDiv.innerHTML = `
                    <i class="fas fa-wand-magic-sparkles suggestion-trigger-icon" title="智慧補貨建議"></i>
                    <div class="chart-card-title">
                        ${store}<br>${machineId}
                        ${(machineSalesTotal > 0 || machineSalesCount > 0) ? `<div class="sales-info">過去一個月銷售: ${machineSalesTotal.toLocaleString()} 元 / ${machineSalesCount} 份</div>` : ''}
                    </div>
                    <div class="chart-card-chart">
                        <canvas id="chart-${key}"></canvas>
                    </div>
                    <div class="chart-card-info">
                        <div>使用量: ${totalQuantity}/${maxCapacity} (${usagePercentage}%)</div>
                        <div>補貨: ${lastUpdatedText}</div>
                    </div>
                `;
                
                // 添加詳細資料視圖內容
                const detailDiv = document.createElement('div');
                detailDiv.className = 'detail-content';
                
                let detailHtml = `
                    <div class="detail-dates">
                        <div>補貨: ${lastUpdatedText}</div>
                    </div>
                `;
                
                if (noteData.address || noteData.note) {
                    if (noteData.address) {
                        detailHtml += `<div class="detail-address">地址: ${noteData.address}</div>`;
                    }
                    if (noteData.note) {
                        detailHtml += `<div class="detail-address">備註: ${noteData.note}</div>`;
                    }
                }
                
                // --- NEW: 銷售排名邏輯 (per-machine, includes sold-out items) ---
                const machineSalesData = salesData ? salesData[store] : null;

                // 創建一個庫存產品的查找表，方便快速獲取庫存量
                const inStockProducts = new Map(products.map(p => [p.name, p.quantity]));
                
                // 獲取所有獨一無二的產品名稱，來源於庫存和銷售兩個列表 (過濾掉空名稱)
                const allProductNames = new Set([
                    ...products.map(p => p.name).filter(Boolean), 
                    ...(machineSalesData ? Object.keys(machineSalesData) : [])
                ]);

                let processedProducts = [];
                allProductNames.forEach(productName => {
                    const salesInfo = machineSalesData ? machineSalesData[productName] : null;
                    processedProducts.push({
                        name: productName,
                        quantity: inStockProducts.get(productName) || 0, // 如果不在庫存列表，數量為0
                        sales: salesInfo ? salesInfo.count : 0,
                        lastSoldDate: salesInfo ? salesInfo.lastSoldDate : ''
                    });
                });

                if (machineSalesData) {
                    processedProducts.sort((a, b) => b.sales - a.sales);
                }

                const medals = ['🥇', '🥈', '🥉'];
                const productsWithSales = processedProducts.filter(p => p.sales > 0);
                const productsWithoutSales = processedProducts.filter(p => p.sales === 0);

                // --- 渲染前三名 (包括空位) ---
                for (let i = 0; i < 3; i++) {
                    const product = productsWithSales[i];
                    if (product) {
                        // 如果有對應排名的產品
                        let tooltipParts = [`過去一個月銷量為 ${product.sales}`];
                        let quantityDisplay = product.quantity;

                        if (product.quantity === 0) {
                            tooltipParts.push(`已在 ${product.lastSoldDate} 完售，請盡早補貨`);
                            quantityDisplay = '⚠️';
                        }
                        
                        detailHtml += `
                            <div class="detail-item">
                                <div>${medals[i]} ${product.name}</div>
                                <div>${quantityDisplay}</div>
                                <span class="detail-tooltip">${tooltipParts.join('，')}</span>
                            </div>
                        `;
                    } else {
                        // 如果沒有對應排名的產品，顯示空位
                        const tooltip = `該機台過去一個月只銷售 ${productsWithSales.length} 樣產品`;
                        detailHtml += `
                            <div class="detail-item">
                                <div>${medals[i]} -</div>
                                <div>-</div>
                                <span class="detail-tooltip">${tooltip}</span>
                            </div>
                        `;
                    }
                }

                // --- 渲染其他已售出產品 (排名第四及以後) ---
                if (productsWithSales.length > 3) {
                     productsWithSales.slice(3).forEach(product => {
                        let quantityDisplay = product.quantity;
                        let tooltipParts = [`過去一個月銷量為 ${product.sales}`];

                        if (product.quantity === 0) {
                            quantityDisplay = '⚠️';
                            tooltipParts.push(`已在 ${product.lastSoldDate} 完售，請盡早補貨`);
                        }

                        detailHtml += `
                            <div class="detail-item">
                                <div>${product.name}</div>
                                <div>${quantityDisplay}</div>
                                <span class="detail-tooltip">${tooltipParts.join('，')}</span>
                            </div>
                        `;
                    });
                }
               
                // --- 渲染無銷售紀錄的產品 ---
                productsWithoutSales.forEach(product => {
                     detailHtml += `
                        <div class="detail-item">
                            <div>${product.name}</div>
                            <div>${product.quantity}</div>
                            <span class="detail-tooltip">該產品於過去一個月未有銷售紀錄</span>
                        </div>
                    `;
                });
                
                detailHtml += `
                    <div class="detail-total">
                        <div>總計</div>
                        <div>${totalQuantity}</div>
                    </div>
                `;
                
                detailDiv.innerHTML = detailHtml;
                cardDiv.appendChild(detailDiv);
                
                chartContainer.appendChild(cardDiv);
                
                // 創建圓餅圖
                setTimeout(() => {
                    try {
                        createDonutChart(key, products);
                    } catch (error) {
                        console.error(`創建圓餅圖失敗 ${key}:`, error);
                    }
                }, 100);

                // 為新創建的卡片上的圖標添加事件監聽器
                cardDiv.querySelector('.suggestion-trigger-icon').addEventListener('click', (event) => {
                    event.stopPropagation(); // 防止觸發卡片的其他點擊事件
                    openSuggestionDialog(key, store, machineId);
                });
            });
        }
        
        // 另存為HTML
        document.getElementById('saveAsHtmlButton').addEventListener('click', function() {
            try {
                // 獲取當前數據現在直接从全局变量获取
                const data = window.inventoryData;
                const notes = window.storeNotesAndAddresses;
                const salesData = window.salesData;
                const selectedSalesMonth = window.selectedSalesMonth;
                const updateTime = window.updateTime;
                const dailySalesTrend = window.dailySalesTrend;
                const fullSalesData = window.fullSalesData;
                const hiddenStores = window.hiddenStores;
                
                if (!data) {
                    throw new Error('無法獲取庫存數據');
                }
                
                // 創建一個新的HTML文檔
                const newDoc = document.implementation.createHTMLDocument('庫存圓餅圖');
                
                // 複製當前文檔的內容
                newDoc.documentElement.innerHTML = document.documentElement.innerHTML;
                
                // 創建數據腳本，確保使用正確的JSON字符串格式
                const scriptContent = `
                    window.embeddedData = ${JSON.stringify(data)};
                    window.embeddedNotes = ${JSON.stringify(notes)};
                    window.embeddedSalesData = ${JSON.stringify(salesData)};
                    window.embeddedSalesMonth = ${JSON.stringify(selectedSalesMonth)};
                    window.embeddedColorMap = ${JSON.stringify(globalProductColorMap)};
                    window.embeddedUpdateTime = ${JSON.stringify(updateTime)};
                    window.embeddedDailySalesTrend = ${JSON.stringify(dailySalesTrend)};
                    window.embeddedFullSalesData = ${JSON.stringify(fullSalesData)};
                    window.embeddedHiddenStores = ${JSON.stringify(hiddenStores)};
                `;
                
                // 創建並插入腳本元素
                const dataScript = newDoc.createElement('script');
                dataScript.textContent = scriptContent;
                
                // 確保腳本在其他腳本之前插入
                const firstScript = newDoc.getElementsByTagName('script')[0];
                firstScript.parentNode.insertBefore(dataScript, firstScript);
                
                // 創建並下載文件
                const blob = new Blob([newDoc.documentElement.outerHTML], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '庫存_' + new Date().toISOString().split('T')[0] + '.html';
                a.click();
                URL.revokeObjectURL(url);
                
                console.log('文件保存成功');
            } catch (error) {
                console.error('保存文件時出錯:', error);
                alert('保存失敗: ' + error.message);
            }
        });
        
        // 截圖按鈕事件處理
        document.getElementById('captureButton').addEventListener('click', function() {
            const loader = document.getElementById('screenshotLoader');
            const body = document.body;

            // 準備截圖
            loader.style.display = 'flex';
            body.classList.add('is-capturing');

            // 稍微延遲以確保樣式應用和渲染穩定
            setTimeout(() => {
                html2canvas(body, {
                    scale: 2, // 提高分辨率
                    useCORS: true,
                    backgroundColor: getComputedStyle(body).backgroundColor, // 使用頁面背景色
                    onclone: (clonedDoc) => {
                        // 在克隆的文檔中，隱藏加載動畫本身，確保它不會出現在截圖中
                        const loaderInClone = clonedDoc.getElementById('screenshotLoader');
                        if (loaderInClone) {
                            loaderInClone.style.display = 'none';
                        }
                    }
                }).then(canvas => {
                    const url = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `庫存截圖_${new Date().toISOString().split('T')[0]}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }).catch(error => {
                    console.error('截圖失敗:', error);
                    alert('截圖失敗: ' + error.message);
                }).finally(() => {
                    // 無論成功或失敗，都進行清理
                    loader.style.display = 'none';
                    body.classList.remove('is-capturing');
                });
            }, 200); // 延遲200毫秒
        });
        
        // 列印
        document.getElementById('printButton').addEventListener('click', function() {
            window.print();
        });
        
        // 修改視圖切換按鈕事件處理
        let currentViewMode = 'chart';
        const toggleViewButton = document.getElementById('toggleViewModeButton');
        
        function updateViewModeButton() {
            const icon = toggleViewButton.querySelector('i');
            const tooltip = toggleViewButton.querySelector('.tooltip');
            
            if (currentViewMode === 'chart') {
                icon.className = 'fas fa-table';
                tooltip.textContent = '切換詳細資料視圖';
            } else {
                icon.className = 'fas fa-chart-pie';
                tooltip.textContent = '切換圓餅圖視圖';
            }
        }

        toggleViewButton.addEventListener('click', function() {
            const cards = document.querySelectorAll('.chart-card');
            
            if (currentViewMode === 'chart') {
                cards.forEach(card => card.classList.add('detail-view'));
                currentViewMode = 'detail';
            } else {
                cards.forEach(card => card.classList.remove('detail-view'));
                currentViewMode = 'chart';
                
                // 重新繪製圓餅圖
                setTimeout(() => {
                    const data = window.inventoryData; // 使用全局數據
                    if (data) {
                        const storeGroups = groupDataByStore(data);
                        for (const storeKey in storeGroups) {
                            try {
                                createDonutChart(storeKey, storeGroups[storeKey].products);
                            } catch (error) {
                                console.error(`重新繪製圓餅圖失敗 ${storeKey}:`, error);
                            }
                        }
                    }
                }, 100);
            }
            
            updateViewModeButton();
        });
        
        // 將數據按機台分組
        function groupDataByStore(data) {
            if (!data || data.length === 0) return {};
            
            // 對數據進行預處理，移除重複的機台信息項
            const cleanedData = data.filter(item => {
                return item.productName !== item.store;
            });
            
            // 按機台分組
            const storeGroups = {};
            cleanedData.forEach(item => {
                const storeKey = `${item.store}-${item.machineId}`;
                if (!storeGroups[storeKey]) {
                    storeGroups[storeKey] = {
                        store: item.store,
                        machineId: item.machineId,
                        lastUpdated: item.lastUpdated,
                        lastCleaned: item.lastCleaned,
                        products: []
                    };
                }
                
                // 檢查是否已經添加過相同的產品
                const existingProduct = storeGroups[storeKey].products.find(p => p.name === item.productName);
                if (!existingProduct) {
                    storeGroups[storeKey].products.push({
                        name: item.productName,
                        quantity: item.quantity
                    });
                }
            });
            
            return storeGroups;
        }
        
        // 載入數據並顯示圖表
        window.addEventListener('DOMContentLoaded', async function() {
            // 新增: 設置報告標題
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const salesReportTitle = document.getElementById('salesReportTitle');
            if(salesReportTitle) {
                salesReportTitle.textContent = `${year}-${month}-${day} 銷售總覽`;
            }

            try {
                console.log('[Debug] DOMContentLoaded: Starting data load process...');
                await loadAllData(); // 使用新的異步加載函數
                
                // 檢查數據是否存在
                if (window.inventoryData) {
                    console.log('[Debug] DOMContentLoaded: Data loaded. Calling displayCharts and setupSalesTrendTab...');
                // 設置庫存視圖
                    displayCharts(window.inventoryData);
                // 設置銷售趨勢視圖
                setupSalesTrendTab(window.fullSalesData);
                    console.log('[Debug] DOMContentLoaded: Render functions called.');
            } else {
                    console.error('[Debug] DOMContentLoaded: window.inventoryData is missing after loadAllData.');
                    throw new Error('數據未成功加載。');
                }
            } catch (error) {
                console.error('[Debug] DOMContentLoaded: Caught an error during initialization.', error);
                document.getElementById('chartContainer').innerHTML = '<p>沒有數據可顯示，請返回主頁面重新生成</p>';
                document.getElementById('summaryText').textContent = '無法載入數據';
                const loadingDiv = document.querySelector('.loading');
                if (loadingDiv) {
                    loadingDiv.style.display = 'none';
                }
            }
        });

        // --- 補貨建議功能 (Replenishment Suggestion) ---
        const suggestionDialog = document.getElementById('suggestionDialog');
        // const suggestionButton = document.getElementById('suggestionButton'); // 不再需要全局按鈕
        const closeSuggestionDialog = suggestionDialog.querySelector('.close');
        const strategyCards = document.querySelectorAll('.strategy-card');
        const generateSuggestionButton = document.getElementById('generateSuggestionButton');
        const suggestionResultContainer = document.getElementById('suggestionResultContainer');
        const reserveSlotsInput = document.getElementById('reserveSlotsInput');
        const onlyAddCheckbox = document.getElementById('onlyAddCheckbox');
        const maxTotalQtyInput = document.getElementById('maxTotalQtyInput');
        const toggleAdvancedOptionsButton = document.getElementById('toggleAdvancedOptionsButton');
        const advancedOptionsCard = document.querySelector('.advanced-options-card');
        const advancedOptionsTable = document.querySelector('.advanced-options-table');
        const suggestionWarning = document.getElementById('suggestionWarning');
        
        let activeSuggestionStoreKey = null;
        let selectedStrategy = 'stable';
        let isFirstRequest = true;

        // 新增：檢查爬蟲狀態
        async function isDataUpdating() {
            try {
                const [invRes, salesRes] = await Promise.all([
                    fetch('/scraper-status'),
                    fetch('/sales-scraper-status')
                ]);
                const invStatus = await invRes.json();
                const salesStatus = await salesRes.json();
                return invStatus.status === 'running' || salesStatus.status === 'running';
            } catch (e) {
                // 若查詢失敗，預設不鎖定
                return false;
            }
        }

        // 自動輪詢鎖定生成建議按鈕
        let suggestionStatusInterval = null;
        function startSuggestionStatusPolling() {
            suggestionStatusInterval = setInterval(async () => {
                if (await isDataUpdating()) {
                    generateSuggestionButton.disabled = true;
                    generateSuggestionButton.innerHTML = '<i class="fas fa-magic"></i> 資料正在更新...';
                } else {
                    generateSuggestionButton.disabled = false;
                    generateSuggestionButton.innerHTML = '<i class="fas fa-magic"></i> 生成建議';
                }
            }, 2000);
        }
        function stopSuggestionStatusPolling() {
            if (suggestionStatusInterval) {
                clearInterval(suggestionStatusInterval);
                suggestionStatusInterval = null;
            }
        }

        // 打開建議對話框 (修改為針對單一卡片)
        function openSuggestionDialog(storeKey, storeName, machineId) {
            activeSuggestionStoreKey = storeKey;
            document.getElementById('suggestionDialogTitle').innerHTML = `<i class=\"fas fa-lightbulb\"></i> 補貨建議: ${storeName} - ${machineId}`;
            suggestionDialog.classList.add('active');
            suggestionResultContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">請點擊 "生成建議" 以載入結果。</p>';
            reserveSlotsInput.value = 0;
            maxTotalQtyInput.value = 50;
            onlyAddCheckbox.checked = false;
            advancedOptionsTable.style.display = 'none';
            suggestionWarning.style.display = 'none';
            suggestionWarning.textContent = '';
            strategyCards.forEach(card => card.classList.remove('selected'));
            document.querySelector('.strategy-card[data-strategy=\"stable\"]').classList.add('selected');
            selectedStrategy = 'stable';
            isFirstRequest = true;
            startSuggestionStatusPolling(); // 新增：開啟時啟動輪詢
        }
        
        // 關閉對話框時停止輪詢
        closeSuggestionDialog.onclick = () => { suggestionDialog.classList.remove('active'); stopSuggestionStatusPolling(); };
        window.onclick = (event) => {
            if (event.target == suggestionDialog) {
                suggestionDialog.classList.remove('active');
                stopSuggestionStatusPolling();
            }
        };

        // 選擇策略
        strategyCards.forEach(card => {
            card.addEventListener('click', () => {
                strategyCards.forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedStrategy = card.dataset.strategy;
            });
        });

        // 生成建議按鈕點擊事件
        generateSuggestionButton.addEventListener('click', async () => {
            if (await isDataUpdating()) {
                suggestionResultContainer.innerHTML = '<p style="color: orange; text-align: center;">資料正在更新，請稍後嘗試</p>';
                return;
            }
            if (!activeSuggestionStoreKey) return;
            if (isFirstRequest) {
                suggestionResultContainer.innerHTML = '<div class="loading" style="position: static; height: 100px;"></div>';
            }
            try {
                const response = await fetch(`/api/replenishment-suggestion/${activeSuggestionStoreKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        strategy: selectedStrategy,
                        reserve_slots: reserveSlotsInput.value || 0,
                        only_add: onlyAddCheckbox.checked,
                        max_total_qty: maxTotalQtyInput.value || 50
                    })
                });

                if (!response.ok) {
                    if (response.status === 503) {
                        throw new Error('資料正在更新，請稍後嘗試');
                    }
                    throw new Error(`伺服器錯誤: ${response.statusText}`);
                }

                const result = await response.json();
                if (result.success) {
                    displaySuggestionResult(result);
                } else {
                    throw new Error(result.message || '生成建議失敗');
                }
                isFirstRequest = false;
            } catch (error) {
                suggestionResultContainer.innerHTML = `<p style="color: red; text-align: center;">錯誤: ${error.message}</p>`;
            }
        });
        
        // 顯示建議結果的函數
        function displaySuggestionResult(result) {
            const { suggestion, message } = result;
            // 新增：檢查是否有警告訊息
            if (result.warning) {
                suggestionWarning.style.display = '';
                suggestionWarning.textContent = result.warning;
            } else {
                suggestionWarning.style.display = 'none';
                suggestionWarning.textContent = '';
            }
            if (message) {
                 suggestionResultContainer.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 20px;">${message}</p>`;
                 return;
            }

            let tableHTML = `
                <table class="suggestion-result-table">
                    <thead>
                        <tr>
                            <th>產品名稱</th>
                            <th>30天銷量</th>
                            <th>目前庫存</th>
                            <th>建議數量</th>
                            <th>調整</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let totalCurrent = 0;
            let totalSuggested = 0;

            suggestion.forEach(item => {
                const adjustment = item.suggestedQty - item.currentQty;
                const adjustClass = adjustment > 0 ? 'positive' : (adjustment < 0 ? 'negative' : '');
                const adjustSign = adjustment > 0 ? '+' : '';
                
                totalCurrent += item.currentQty;
                totalSuggested += item.suggestedQty;

                tableHTML += `
                    <tr>
                        <td>${item.productName}</td>
                        <td>${item.salesCount30d}</td>
                        <td>${item.currentQty}</td>
                        <td>${item.suggestedQty}</td>
                        <td class="qty-adjust ${adjustClass}">${adjustSign}${adjustment}</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                    <tfoot>
                        <tr style="font-weight: bold; border-top: 2px solid #ddd;">
                            <td>總計</td>
                            <td></td>
                            <td>${totalCurrent}</td>
                            <td>${totalSuggested}</td>
                            <td></td>
                        </tr>
                    </tfoot>
                </table>
            `;

            suggestionResultContainer.innerHTML = tableHTML;
        }

        // 添加教學區塊的展開/收合功能
        document.querySelector('.tutorial-header').addEventListener('click', function() {
            const tutorial = this.parentElement;
            const content = tutorial.querySelector('.tutorial-content');
            const icon = this.querySelector('.fa-chevron-down');
            
            tutorial.classList.toggle('open');
            
            // 更新箭頭圖標
            if (tutorial.classList.contains('open')) {
                icon.style.transform = 'rotate(180deg)';
            } else {
                icon.style.transform = 'rotate(0deg)';
            }
        });

        // 分頁切換邏輯
        document.querySelectorAll('.tab-link').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;

                // 更新按鈕狀態
                document.querySelectorAll('.tab-link').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 更新內容顯示
                document.querySelectorAll('.tab-content').forEach(content => {
                    if (content.id === tabId) {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                });
            });
        });

        // 新增：銷售趨勢頁面截圖按鈕
        document.getElementById('captureSalesTabButton').addEventListener('click', function() {
            const loader = document.getElementById('screenshotLoader');
            const body = document.body;
            
            // 準備截圖
            loader.style.display = 'flex';
            body.classList.add('is-capturing', 'is-capturing-sales', 'is-capturing-sales-wide');

            // 強制圖表重新計算尺寸
            if (mainSalesChartInstance) {
                mainSalesChartInstance.resize();
            }

            // 稍微延遲以確保圖表渲染完成
            setTimeout(() => {
                html2canvas(body, {
                    scale: 2, // 提高分辨率
                    useCORS: true,
                    backgroundColor: getComputedStyle(body).backgroundColor,
                    onclone: (clonedDoc) => {
                        // 在克隆的文檔中，隱藏加載動畫本身
                        const loaderInClone = clonedDoc.getElementById('screenshotLoader');
                        if (loaderInClone) {
                            loaderInClone.style.display = 'none';
                        }
                    }
                }).then(canvas => {
                    const reportTitle = document.getElementById('salesReportTitle').textContent.trim() || '銷售趨勢報告';
                    const url = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${reportTitle}_${new Date().toISOString().split('T')[0]}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }).catch(error => {
                    console.error('截圖失敗:', error);
                    alert('截圖失敗: ' + error.message);
                }).finally(() => {
                    // 清理
                    loader.style.display = 'none';
                    body.classList.remove('is-capturing', 'is-capturing-sales', 'is-capturing-sales-wide');
                    
                    // 將圖表尺寸恢復正常
                    if (mainSalesChartInstance) {
                        mainSalesChartInstance.resize();
                    }
                });
            }, 300); // 增加延遲確保渲染
        });

        toggleAdvancedOptionsButton.addEventListener('click', () => {
            if (advancedOptionsTable.style.display === 'none') {
                advancedOptionsTable.style.display = '';
            } else {
                advancedOptionsTable.style.display = 'none';
            }
        });

        // Chart.js Glassmorphism 背景 Plugin
        Chart.register({
            id: 'glassmorphismBackground',
            beforeDraw: function(chart, args, options) {
                const {ctx, width, height} = chart;
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = window.chartGlassBg || 'rgba(255,255,255,0.18)';
                ctx.filter = 'blur(4px)';
                ctx.fillRect(0, 0, width, height);
                ctx.filter = 'none';
                ctx.restore();
            }
        });
    </script>
</body>
</html> 